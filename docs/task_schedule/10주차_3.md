완벽해요 😎
이건 진짜 “운영자 수준의 자동화 시스템”으로 가는 단계예요.
이제 단순히 DB를 정리하는 게 아니라,
**AI 서비스 운영자가 볼 수 있는 자동 Slack 알림까지 통합한 버전**을 만들어드릴게요.

---

# 🧭 목표

✅ 오래된 로그 자동 백업 + 삭제
✅ 백업 결과를 **Slack으로 자동 알림**
✅ Render 무료 플랜에서도 `/run-cleanup` 호출로 작동

---

## 📁 파일 이름

`app/utils/db_cleanup.py`

---

```python
"""
db_cleanup.py
----------------------------------------
오래된 로그 백업 및 정리 + Slack 알림 확장 버전
----------------------------------------
- conversation_log 테이블의 오래된 데이터를 CSV로 백업 후 삭제
- 백업 결과를 Slack에 자동 보고
- Render 무료 플랜에서도 /run-cleanup 엔드포인트로 실행 가능
"""

import os
import pandas as pd
from datetime import datetime, timedelta
from sqlalchemy import create_engine, text
import requests

# -----------------------------------
# 1️⃣ 환경 변수 설정
# -----------------------------------
DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///./local.db")
SLACK_BOT_TOKEN = os.getenv("SLACK_BOT_TOKEN")
SLACK_CHANNEL = os.getenv("SLACK_CHANNEL", "ai-reports")
LOG_RETENTION_DAYS = int(os.getenv("LOG_RETENTION_DAYS", 30))

engine = create_engine(DATABASE_URL)

# 백업 폴더
BACKUP_DIR = os.path.join(os.path.dirname(os.path.dirname(__file__)), "..", "backups")
os.makedirs(BACKUP_DIR, exist_ok=True)

# -----------------------------------
# 2️⃣ Slack 메시지 전송 함수
# -----------------------------------
def send_slack_message(text, file_path=None):
    """Slack에 텍스트 및 파일 전송"""
    if not SLACK_BOT_TOKEN:
        print("⚠️ SLACK_BOT_TOKEN not set. Skipping Slack notification.")
        return

    headers = {"Authorization": f"Bearer {SLACK_BOT_TOKEN}"}
    data = {"channels": SLACK_CHANNEL, "initial_comment": text}

    # 파일이 있으면 첨부
    if file_path and os.path.exists(file_path):
        with open(file_path, "rb") as f:
            response = requests.post(
                "https://slack.com/api/files.upload",
                headers=headers,
                data=data,
                files={"file": f},
            )
    else:
        response = requests.post(
            "https://slack.com/api/chat.postMessage",
            headers=headers,
            json={"channel": SLACK_CHANNEL, "text": text},
        )

    if response.status_code == 200:
        print(f"✅ Slack 메시지 전송 완료: {SLACK_CHANNEL}")
    else:
        print(f"❌ Slack 전송 실패: {response.text}")

# -----------------------------------
# 3️⃣ 백업 및 정리 함수
# -----------------------------------
def backup_and_cleanup_logs():
    """오래된 로그 백업 및 삭제"""
    cutoff_date = datetime.utcnow() - timedelta(days=LOG_RETENTION_DAYS)
    print(f"🗓️  백업 기준일: {cutoff_date}")

    # 오래된 로그 가져오기
    query = text("SELECT * FROM conversation_log WHERE created_at < :cutoff")
    df = pd.read_sql(query, engine, params={"cutoff": cutoff_date})

    if df.empty:
        msg = f"✅ 백업할 오래된 로그가 없습니다. (기준: {cutoff_date.date()})"
        print(msg)
        send_slack_message(msg)
        return

    # CSV 백업 파일 생성
    backup_filename = f"conversation_log_backup_{cutoff_date.strftime('%Y%m%d')}.csv"
    backup_path = os.path.join(BACKUP_DIR, backup_filename)
    df.to_csv(backup_path, index=False, encoding="utf-8-sig")

    print(f"💾 백업 완료: {backup_path} ({len(df)} rows)")

    # DB에서 삭제
    delete_query = text("DELETE FROM conversation_log WHERE created_at < :cutoff")
    with engine.begin() as conn:
        conn.execute(delete_query, {"cutoff": cutoff_date})

    print(f"🧹 {len(df)}개의 오래된 로그 삭제 완료 ✅")

    # Slack 알림 전송
    message = (
        f"💾 *DB Cleanup Report*\n"
        f"- 백업 파일: `{backup_filename}`\n"
        f"- 백업 수: {len(df)} rows\n"
        f"- 삭제 기준일: {cutoff_date.date()}\n"
        f"- 실행 시간: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')}"
    )
    send_slack_message(message, backup_path)


if __name__ == "__main__":
    backup_and_cleanup_logs()
```

---

## 📊 실행 예시 (로컬)

```bash
poetry run python -m app.utils.db_cleanup
```

결과:

```
🗓️  백업 기준일: 2025-09-15 00:00:00
💾 백업 완료: backups/conversation_log_backup_20250915.csv (124 rows)
🧹 124개의 오래된 로그 삭제 완료 ✅
✅ Slack 메시지 전송 완료: ai-reports
```

Slack 메시지 예시 💬

```
💾 DB Cleanup Report
- 백업 파일: conversation_log_backup_20250915.csv
- 백업 수: 124 rows
- 삭제 기준일: 2025-09-15
- 실행 시간: 2025-10-15 09:00:00 UTC
📎 첨부: CSV 파일
```

---

## 📁 경로 구조 (추천)

```
ai-career-6months/
 ┣ app/
 ┃ ┣ utils/
 ┃ ┃ ┣ report_utils.py
 ┃ ┃ ┗ db_cleanup.py      👈 (이 파일)
 ┃ ┗ routes/
 ┃   ┗ maintenance.py     👈 /run-cleanup 라우터
 ┣ backups/               👈 백업 CSV 저장 폴더
 ┣ reports/
 ┗ ...
```

---

## 🌐 FastAPI 연동 (`app/routes/maintenance.py`)

```python
from fastapi import APIRouter, BackgroundTasks
from app.utils.db_cleanup import backup_and_cleanup_logs

router = APIRouter()

@router.get("/run-cleanup")
def run_cleanup(background_tasks: BackgroundTasks):
    """백업 및 정리를 백그라운드에서 실행"""
    background_tasks.add_task(backup_and_cleanup_logs)
    return {"status": "Cleanup started in background."}
```

이제 `https://yourapp.onrender.com/run-cleanup` 을 호출하면
→ 백그라운드에서 DB 정리 + Slack 보고까지 자동 수행됩니다 ✅

---

## 🧠 환경 변수 (.env.prod or Render 환경 설정)

```bash
DATABASE_URL=postgresql+psycopg2://user:pass@host/db?sslmode=require
SLACK_BOT_TOKEN=xoxb-1234-your-slack-token
SLACK_CHANNEL=ai-reports
LOG_RETENTION_DAYS=30
```

---

## ☁️ Render 무료 플랜 자동화 방법

Render의 무료 플랜에서는 Background Worker가 없으므로
🔹 `cron-job.org` 나 GitHub Actions에서 다음을 호출하도록 설정:

```
GET https://yourapp.onrender.com/run-cleanup
```

예: cron-job.org 설정

* URL: 위 주소
* 주기: 매주 월요일 09:00 (KST)
* 인증 불필요

---

## 💾 Slack 전송 구조 요약 (시퀀스)

```mermaid
sequenceDiagram
    participant Cron as 🕒 cron-job.org
    participant FastAPI as ☁️ /run-cleanup
    participant DB as 🗃 conversation_log
    participant Slack as 💬 Slack Channel

    Cron->>FastAPI: GET /run-cleanup
    FastAPI->>DB: SELECT * FROM conversation_log WHERE created_at < cutoff
    FastAPI->>FastAPI: CSV로 백업 + DELETE 실행
    FastAPI->>Slack: 파일 + 메시지 업로드
    Slack-->>User: 💾 백업 결과 알림 도착
```

---

## ✅ 정리

| 기능                 | 설명                             |
| ------------------ | ------------------------------ |
| 🗃 오래된 로그 백업       | 30일 이상된 로그 → CSV 저장            |
| 🧹 DB 정리           | 백업 완료 후 DB에서 삭제                |
| 💬 Slack 자동 알림     | 파일 + 결과 요약 자동 보고               |
| ☁️ Render 무료 플랜 호환 | `/run-cleanup` 엔드포인트 + 외부 스케줄러 |
| 📅 주기              | 매주 1회 또는 매일 1회 설정 가능           |

---

원하신다면 🔥
다음 단계로 이 백업 리포트를 Slack뿐 아니라
**Google Drive에도 자동 업로드**하도록 확장해드릴까요?
(→ `gdrive` API를 통해 백업 CSV가 자동으로 Drive에 저장되는 버전)
