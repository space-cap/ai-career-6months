와…👏 진짜 핵심적인 질문이에요.
이건 “**운영형 AI 프로젝트 구조를 설계할 때 생기는 전형적인 리팩토링 포인트**”예요.

정확히 맞습니다 —
✅ `send_slack_message()` 는 **여러 모듈에서 반복적으로 사용되는 공통 기능**이에요.
즉, “리포트 전송 / 백업 알림 / 에러 알림 / 평가 결과 보고” 등
여러 곳에서 Slack 통합이 반복되죠.

그래서 이건 **공용 유틸로 분리하는 게 정답**이에요 💯

---

# 🧩 리팩토링 방향

| 기존                        | 개선 후                                 |
| ------------------------- | ------------------------------------ |
| 각 파일마다 Slack 메시지 전송 코드 중복 | `app/utils/slack_notifier.py` 하나로 통합 |
| HTTP 요청, 헤더, 채널 설정이 중복됨   | 재사용 가능 함수 + 간단한 import               |
| 에러 시 일관되지 않은 로그           | 통합 로깅 및 예외처리 가능                      |

---

# 📁 **추천 구조**

```
ai-career-6months/
 ┣ app/
 ┃ ┣ utils/
 ┃ ┃ ┣ slack_notifier.py     👈 공통 Slack 유틸
 ┃ ┃ ┣ report_utils.py
 ┃ ┃ ┗ db_cleanup.py
 ┃ ┣ routes/
 ┃ ┃ ┣ report.py
 ┃ ┃ ┗ maintenance.py
 ┃ ┗ ...
 ┗ ...
```

---

# 📘 **`app/utils/slack_notifier.py`**

```python
"""
slack_notifier.py
----------------------------------
Slack 메시지 및 파일 업로드 공통 유틸
----------------------------------
- Slack BOT Token 및 Channel 환경변수 기반
- 텍스트, 파일 전송 모두 지원
- 모든 모듈에서 import 후 재사용 가능
"""

import os
import requests

SLACK_BOT_TOKEN = os.getenv("SLACK_BOT_TOKEN")
SLACK_CHANNEL = os.getenv("SLACK_CHANNEL", "ai-reports")

def send_slack_message(text: str, file_path: str = None):
    """Slack으로 메시지 또는 파일 전송"""
    if not SLACK_BOT_TOKEN:
        print("⚠️ SLACK_BOT_TOKEN not set. Skipping Slack message.")
        return {"ok": False, "error": "missing_token"}

    headers = {"Authorization": f"Bearer {SLACK_BOT_TOKEN}"}
    data = {"channels": SLACK_CHANNEL, "initial_comment": text}

    try:
        # 파일이 있으면 파일 업로드
        if file_path and os.path.exists(file_path):
            with open(file_path, "rb") as f:
                response = requests.post(
                    "https://slack.com/api/files.upload",
                    headers=headers,
                    data=data,
                    files={"file": f},
                )
        else:
            # 텍스트 메시지 전송
            response = requests.post(
                "https://slack.com/api/chat.postMessage",
                headers=headers,
                json={"channel": SLACK_CHANNEL, "text": text},
            )

        result = response.json()
        if result.get("ok"):
            print(f"✅ Slack 전송 완료 → #{SLACK_CHANNEL}")
        else:
            print(f"❌ Slack 오류: {result.get('error')}")
        return result

    except Exception as e:
        print(f"❌ Slack 전송 중 예외 발생: {e}")
        return {"ok": False, "error": str(e)}
```

---

# 📗 **`app/utils/db_cleanup.py` (리팩토링된 버전)**

```python
from datetime import datetime, timedelta
from sqlalchemy import create_engine, text
import os, pandas as pd
from app.utils.slack_notifier import send_slack_message  # ✅ 공용 모듈 import

DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///./local.db")
engine = create_engine(DATABASE_URL)
LOG_RETENTION_DAYS = int(os.getenv("LOG_RETENTION_DAYS", 30))

BACKUP_DIR = os.path.join(os.path.dirname(os.path.dirname(__file__)), "..", "backups")
os.makedirs(BACKUP_DIR, exist_ok=True)

def backup_and_cleanup_logs():
    cutoff_date = datetime.utcnow() - timedelta(days=LOG_RETENTION_DAYS)
    print(f"🗓️ 백업 기준일: {cutoff_date}")

    df = pd.read_sql("SELECT * FROM conversation_log WHERE created_at < :cutoff", engine, params={"cutoff": cutoff_date})
    if df.empty:
        msg = f"✅ 백업할 오래된 로그가 없습니다. (기준: {cutoff_date.date()})"
        print(msg)
        send_slack_message(msg)
        return

    backup_filename = f"conversation_log_backup_{cutoff_date.strftime('%Y%m%d')}.csv"
    backup_path = os.path.join(BACKUP_DIR, backup_filename)
    df.to_csv(backup_path, index=False, encoding="utf-8-sig")

    delete_query = text("DELETE FROM conversation_log WHERE created_at < :cutoff")
    with engine.begin() as conn:
        conn.execute(delete_query, {"cutoff": cutoff_date})

    msg = (
        f"💾 *DB Cleanup Report*\n"
        f"- 파일: `{backup_filename}`\n"
        f"- 백업 수: {len(df)} rows\n"
        f"- 기준일: {cutoff_date.date()}\n"
        f"- 실행: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')}"
    )

    send_slack_message(msg, backup_path)
    print("✅ 백업 및 Slack 전송 완료.")
```

---

# 📙 **다른 모듈에서도 재사용 가능**

### ✅ `app/utils/report_utils.py`

```python
from app.utils.slack_notifier import send_slack_message

def generate_and_send_report():
    ...
    send_slack_message("📊 Daily Report Generated", "reports/sentiment_ratio.png")
```

### ✅ `app/evaluate_response.py`

```python
from app.utils.slack_notifier import send_slack_message

def run_evaluation():
    ...
    send_slack_message("🤖 Evaluation Complete", None)
```

---

# 🧠 **이렇게 구조를 바꾸면 생기는 장점**

| 항목                | 효과                                         |
| ----------------- | ------------------------------------------ |
| 🎯 **코드 중복 제거**   | Slack 관련 코드가 한 파일로 통합                      |
| 🧩 **유지보수성 향상**   | Slack API 바뀌어도 한 곳만 수정                     |
| 💬 **일관된 메시지 포맷** | 알림 스타일 통일 (이모지, 서식, 채널)                    |
| ⚙️ **확장 용이성**     | 나중에 Discord, Email 알림 추가도 쉬움               |
| ☁️ **환경변수 일원화**   | `SLACK_BOT_TOKEN`, `SLACK_CHANNEL` 한 번만 관리 |

---

# 💡 확장 아이디어 (다음 단계)

✅ `send_slack_message()`를 더 고도화해서:

* `message_type` 매개변수 (`info`, `error`, `success`)로 메시지 스타일 변경
* `attachments` / `blocks` API로 **차트 요약 시각화 지원**
* `thread_ts`로 **리포트 스레드 관리 (1주일치 묶음)**

---

요약하자면 👇

> `send_slack_message()`는 **무조건 따로 분리**하는 게 정답이에요.
> 이걸 `app/utils/slack_notifier.py`로 빼두면
> DB 정리, 리포트, 평가, 배포 알림 등 모든 곳에서 재사용 가능하고
> 운영형 프로젝트 수준으로 깔끔해집니다. ✅

---

원하신다면 ✨
`send_slack_message()`를 **message_type별 스타일링 (성공✅ / 경고⚠️ / 오류❌)** 로 확장한
**프로덕션 알림 버전**으로 만들어드릴까요?
(→ 메시지 색상, 이모지, 헤더, 텍스트 자동 포맷 포함)
